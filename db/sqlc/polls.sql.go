// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.14.0
// source: polls.sql

package db

import (
	"context"
)

const createPolls = `-- name: CreatePolls :exec
INSERT INTO polls (poll_by,poll_question,options_count,options)
VALUES (?,?,?,?)
`

type CreatePollsParams struct {
	PollBy       string `json:"poll_by"`
	PollQuestion string `json:"poll_question"`
	OptionsCount int32  `json:"options_count"`
	Options      string `json:"options"`
}

func (q *Queries) CreatePolls(ctx context.Context, arg CreatePollsParams) error {
	_, err := q.exec(ctx, q.createPollsStmt, createPolls,
		arg.PollBy,
		arg.PollQuestion,
		arg.OptionsCount,
		arg.Options,
	)
	return err
}

const getPolls = `-- name: GetPolls :many
select polls.poll_id,polls.poll_question,polls.options_count,polls_reaction.type,count(*) from polls
inner join polls_reaction on polls.poll_id = polls_reaction.poll_id
group by polls.poll_id, polls.poll_question, polls.options_count,polls_reaction.type
`

type GetPollsRow struct {
	PollID       int32  `json:"poll_id"`
	PollQuestion string `json:"poll_question"`
	OptionsCount int32  `json:"options_count"`
	Type         int32  `json:"type"`
	Count        int64  `json:"count"`
}

func (q *Queries) GetPolls(ctx context.Context) ([]*GetPollsRow, error) {
	rows, err := q.query(ctx, q.getPollsStmt, getPolls)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetPollsRow{}
	for rows.Next() {
		var i GetPollsRow
		if err := rows.Scan(
			&i.PollID,
			&i.PollQuestion,
			&i.OptionsCount,
			&i.Type,
			&i.Count,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
